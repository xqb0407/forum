/*
Navicat MySQL Data Transfer

Source Server         : 本地数据库
Source Server Version : 50718
Source Host           : 127.0.0.1:3306
Source Database       : forum

Target Server Type    : MYSQL
Target Server Version : 50718
File Encoding         : 65001

Date: 2021-01-30 12:27:35
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `category` bigint(20) DEFAULT NULL COMMENT '类目 1-分享 2-讨论 3-建议 4-公告 5-动态',
  `label` bigint(20) DEFAULT NULL COMMENT '标签  1-精贴 2-垃圾文章',
  `uId` int(11) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL COMMENT '发文时间',
  `content` text COMMENT '文章内容',
  `title` varchar(255) DEFAULT NULL COMMENT '查看',
  `show_count` int(11) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `用户主键` (`uId`),
  CONSTRAINT `用户外键` FOREIGN KEY (`uId`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=123 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('2', '1', '0', '2', '2021-01-28 07:57:39', '\n\nJetsam机制清理策略可以总结为以下几点：\n单个APP物理内存占用超过上限会被清理，不同的设备内存水位线不一样。\n整个设备物理内存占用受到压力时，优先清理后台应用，再清理前台应用。\n优先清理内存占用高的应用，再内存占用低的应用。\n相比系统应用，会优先清理用户应用。\nAndroid端为Low Memory Killer：\n', '高德地图驾车导航内存优化原理与实战', '0', '2021-01-28 07:57:39');
INSERT INTO `article` VALUES ('3', '1', '0', '2', '2021-01-28 08:00:32', '芯片领域洗牌，国产芯片厂商的突破口在何处？\n\n作者 | 马超       责编 | 屠敏\n\n出品 | CSDN（ID：CSDNnews）\n\n“时来天地皆同力，运去英雄不自由”。\n\n计算机背后的集成电路已由上世纪 40 年代占地 150 平方米、重达 30 吨的庞然大物，演进成仅有手指般大小的超高密度的电子芯片。芯片是 IT 时代的算力底座，市场规模近万亿美元，但这个领域一直是我们被“卡脖子”的软肋。\n\n近日，接连不断的并购案和频繁涌现的新品发布，让芯片行业处于前所未有的大变局之中。\n\n去年 9 月，英伟达宣布以 400 亿美元的价格从软银手中收购 Arm，以加强自己在 CPU 方面的短板，凭借 CPU+GPU 的方式正式进军云数据中心；10 月，英特尔宣布将 NAND 业务以 90 亿美元的价格卖给 SK 海力士；同月，AMD 收购 FPGA 行业的巨头 Xilinx，同样剑指云数据中心；而这样纷繁复杂的局面在一代神芯苹果 M1 发布之后变得更加扑朔迷离。\n\n不仅如此，近期英特尔也官宣将在一个月后换帅，现任掌门人 Bob Swan 此前是英特尔的财务官，缺乏技术方面的专业背景。可能也正是由于这方面的欠缺，英特尔在技术层面衍生出许多问题，迟迟陷在 14nm 制程上无法突破，也带来了\"火线换帅\"的局面。\n\n此外，另一巨头英伟达带着 RTX3060 也正式登场，并采用了 3584 CUDA 核心，GPU 频率可达 1.78G Hz，配备了 12GB 的 GDDR6 显存，可以说英伟达在显卡市场上也开始拼尽全力了。\n\n\n\n在此趋势下，我们不仅要看清芯片巨头们的竞争格局，更要躬身入局，加快我们自身的追赶步伐。也希望本文能为正走在这条道路上的技术人们带来一些思考。\n\n\n\n苹果 M1 芯片“抗打”\n\n众所周知，IT 界每十年就会产生一种新的生态，如二十年前的 Wintel 的 PC 生态、如十年前 Android、iOS+ARM 形成的移动终端生态，未来的一两年内，想必也会有新生态形成，因此哪种芯片能够领先竞争对手，那么谁的生态就可能笑傲江湖，而统治 IT 生态对于科技巨头而言是保持基业常青的最大砝码，这也是苹果耗费巨大精力也要打造出 M1 的主要原因。\n\nM1 的优胜原因在于，目前计算机的体系架构更偏向于划定界限明确分工，CPU、内存等模块都是彼此都是独立的，不过 M1 打破了这个潜规则，本质上 M1 并不是一颗传统意义上的 CPU，而是 CPU、GPU、内存乃至协处理器集成在一块 SOC 上的微型主机。\n\n不过，这样做的缺点是扩展性差，使用 M1 的主机无法扩展内存，但这样的好处也非常明显，集成式 SOC 所带来的性能提升令人惊叹。据最新的评测来看，M1 的单核得分超过了 AMD 最新的 ZEN 3 架构的 Ryzen 9 5950X 和 Intel i9-10900K。\n\nM1 不仅 CPU 性能强悍，它的图形性能也很出众，已经完全脱离了之前业界对于集成显卡的理解范围。据数据显示，M1 的显卡性能与英伟达的 GTX 1650 与 GTX 1050Ti 之间，比目前轻薄本主流集成显卡性能高出好几个数量级。\n\n另外，M1 的功耗也非常低。据网友用《古墓丽影:崛起》进行测试案例结果时，M1 的平均功率分别是 CPU 7.5W、GPU 7W，作为对比仅是 1650 显卡功率要求就有 75W。\n\n这样的表现除了对笔记本桌面市场带来一定震撼外，也为云数据中心指明了一条道路。毕竟，云数据中心不仅对于电力消耗的要求极其高，而且如何为服务器降温更是一个巨大的课题，业界中如微软、Facebook 等企业此前为了解决这一难题甚至将数据中心建到海底，阿里云也有液冷服务器的技术，当然这些都是针对 CPU 这个耗能大户设计的，如果能 CPU 耗能低到 10w 以内，将对于云计算服务商产生巨大的吸引力。\n\n目前云操作系统基本是 Linux 的天下，这意味着，一旦低耗能高性能的 M1 可以平稳运行 Linux，那么云平台和 Android 平台的大量生态级应用就可以全部被 ARM 和开源的联盟收入囊中，这样带来的可能性正是开源社区正在全力向 M1 上移植 Linux 的原因，而如何面对 M1 集成式 SOC 的趋势将是今后各大巨头的必须要回答的问题。\n\n\n\n英特尔“求变”\n\n相比之下，另一科技巨头英特尔的处境似乎不太好，一直以来 CPU 领域的跟随者 AMD 已经大有后来者居上的气势，不但推出了 ZEN3 架构的 CPU，制程 7nm 性价比也全面超越它，并且还收购了人工智能领域 FPGA 芯片巨头赛灵思。\n\n英特尔在 14nm 制造上迟迟无法突破，而苹果这样的消费者硬件厂商，对于先进制程芯片带来的节能效应还是非常看重的，因此苹果发布自研 M1 终止与英特尔合作，这使得英特尔无论如何也不能再挤牙膏了。\n\n英特尔于日前宣布任命帕特.基辛格为新任 CEO，与前任 CEO 财务出身不同，基辛格是与英特尔一起成长起来的技术专家，新帅基辛格的回归势必要剑指先进制程。\n\n不过，近来以来，芯片市场中桌面业务明显趋于萎缩，而云计算领域却是不断增长，英伟达收购 ARM、AMD 收购赛灵思其实都是在布局云数据中心。在这里，不得不提一下基辛格的前东家，2012 年，基辛格接手 VMware CEO 一职，经过多年的努力，如今 VMware 在云计算方面几乎没有敌手，取得了营收翻 3 倍的成绩，且在虚拟化云计算领域也是佼佼者，因此基辛格的王者归来，让大家对英特尔充满了期待，也相信英特尔将很快会重新取得突破，迎来崭新未来。\n\n\n\nAMD vs NVIDIA：关键在制程\n\n在显卡市场，一直被英伟达（NVIDIA）吊打的 AMD 也在近期迎来了高光时刻，AMD 在去年年底发布的 RX6000 系列显卡在很多方面几乎反过来压制了英伟达同级别的 GPU。事实上，制约显卡性能最大的因素在于带宽，而RX6000 系列有 RDNA 2 无限缓存技术的加持，相比 RDNA 带宽提升 50%，频率提升 30%，这意味着 RDNA 2 的默频可以轻松达到 2G 以上，这对于性能的提升幅度将是巨大的，而微软官宣 XBox X|S 是全球唯一搭载 RDNA 2的游戏主机平台，这样的表态可以看作是微软对于 AMD 显卡性能的一种“背书”。\n\n而 AMD 能在 CPU 领域与英特尔一较长短，在 GPU 也能和英伟达正面较量的关键原因还是在于制程。\n\n此前，由于财务原因，AMD 在 2008 年底卖掉了自己的晶圆厂，自此以后，AMD 的主要芯片代工制造商就是台积电，这样的结盟使得 AMD 能够率先用上 7nm 的制程。正如我们上文所说，能掌握先进节能的芯片，对于 IT 厂商建立自身生态意义非凡，因此才会出现众巨头争抢台积电产能的情况。\n\n凭借对先进制程的把握与高超的芯片工艺水平，近些年来，英伟达也将很多之前属于三星的订单转投给台积电，根据今年三季度的财务，台积电这家芯片制造业的巨头今年的毛利润率已经达到了 53%，这代表他们芯片制造的成本还不到出厂价的一半，这在世界 500 强的公司当中是绝无仅有的，甚至远超被称为 IT 界奢侈品牌的苹果公司。\n\n建设和维护晶圆厂实在太花钱了，还需要不断按部就班的升级工艺，业界目前也就台积电和三星两大玩家。由于分工的明确化，台积电从起家就一直专注于芯片代工，不仅工艺升级非常快，而且在良品率上也很让人满意，而且台积电多年来从来没有涉及过芯片设计，对 AMD、英伟达这类客户芯片 IP 保护工作做的非常好，也正是由于专注在芯片制造，台积电才有精力和财力把业务做好做大，这也符合未来芯片行业的分工趋势。\n\n基于以上，在看清巨头的纷争后，我们还是要解决自己的问题，在打压了华为、大疆以后，最近美国又把目光盯上了小米、中微电子等公司，通过分析巨头们的策略，笔者认为针对芯片的不同领域，我们需要采用不同的策略加以应对。\n\n\n\n国芯前路之 EDA：\n\n相信时间累积而非资本力量\n\nEDA 其实是工业软件计算机辅助设计 CAD 的一个分支，依靠 EDA 工具，芯片设计人员可以从概念、算法、协议等开始设计电子系统，完成电子产品从电路设计、性能分析到设计出 IC 版图或 PCB 版图的整个过程。\n\n有数据显示，2018 年全球 EDA 市场规模还没突破 100 亿美元，EDA 相对于几千亿美元的芯片产业来说从产值上看根本不值一提，不过少了 EDA 整个芯片产业都得停摆。EDA 市场前三位的 Synopsys、Cadence 和西门子在我国 EDA 的市场份额达到 95% 以上，因此 EDA 软件是我们芯片行业亟待突破的第一关。\n\nEDA 行业是一个典型的小而美的行业，可分为前端和后端，前端主要负责逻辑实现，后端跟工艺紧密结合。\n\n与 MATLAB 等工业软件一样，EDA 的前端技术需要最新逻辑元件的资料输入，不过大部分国产 EDA 厂商还无法支持 7nm 的逻辑元件，与台积电、三星等顶级芯片制造商的联系较少，巧妇难为无米之炊，没有最新工艺资料 EDA 前端，很难真正做好。\n\nEDA 后端则需要高质量的模拟与仿真，这需要长时间的技术积累，乃至不断地并购才能保持自身在技术迭代的浪潮中保持优势的方法。笔者认为想解决国内的 EDA 软件问题，或可从以下几个方面入手：\n\n国家层面不断推动企业整合。这方面美国的经验非常值得我们借鉴，他们的 EDA 企业并非没有过恶性竞争，不过政府并没有放任这种竞争的持续而是直接出手干预了市场。EDA 三巨头之一的 Synopsys 成立以来，就发起几十余项并购交易，不断寻找那些在 EDA 功能模块中做得比较有特色的成功企业进行并购，从而使得自身能够覆盖前后端整个设计流程。\n\n尤其是 2002 年 Synopsys 在美国商务部、司法部的牵线下，以 8.3 亿美元收购了 Avanti 公司，使得 Synopsys 成为 EDA 历史上第一家可以提供顶级前后端完整 IC 设计方案的领先 EDA 工具供应商，并在 2008 年超越 Cadence 成为全球最大的 EDA 工具厂商。\n\n而值得注意的是，在此之前 Avanti 一直与 Cadence 公司深陷于专利官司之中，这场并购几乎由美国政府主导，也正是通过这样的并购，使得美国的 EDA 公司结束了专利内斗，迅速拓展并占领了海外市场。\n\n持续提高投入。以 EDA 的三巨头为例，从三家公司财务来看，其最大支出部分用于产品的研发，其中 Synopsys 和 Cadence 这两家公司在 2019 年的研发支出超过了 20 亿美元。\n\n加大人才培养力度。综合来看，国内包括芯愿景、华大九天等在内的 EDA 公司，最大短板在于研发力量的薄弱，而我们需要不断加强人才的培养与输出。\n\n\n\n国芯前路之指令集：重点突破优先\n\n既使有了 EDA 软件，进行芯片设计了，我们的芯片设计师们在动手之前，也必须先决定芯片的指令集。\n\n指令集之所以重要，举例说明，正如 x86 芯片中有 SSE（Stream SIMDExtentions）数据流单指令多数据扩展，SSE 系列指令提供了 8 个 128bit 的寄存器进行 SIMD 操作。\n\n目前主流的 CPU 是 64 位的，即在一个 CPU 振荡周期都只能处理 64 位长的数据并得到一个 64 位长的结果，而 SSE 的扩展恰恰就是可让 64 位的 CPU 在一个周期内对 128 位长的数据进行处理并得到 128 位长的结果，从而大幅提高双精度数据的处理效率。因此我们看到很多用于科学计算的软件包底层都是使用 C 语言内联嵌入 SSE 汇编指令的代码进行性能优化，并取得极好的效果。而 ARM 系列芯片的成名之作就是大小核，其中大核专门针对性能优化，小核专门针对功耗优化，可谓忙时用大核干得欢，闲时用小核歇得爽。像这样的芯片指令集都是被专利保护的，想使用必须得到 IP 授权，因此指令集也是一个我们必须直面困难的领域。\n\n目前我国拥有完整知识产权的芯片指令集就是龙芯在去年底时发布的 LoongArch。LoongArch 是一种可以支持模拟运行 x86 或者 ARM 的指令集，因此可以深度兼容 Windows、Linux、Android 程序，但是这种模拟运行也有性能损耗，而且从目前来看这种性能代价还是不小的，当然据笔者所知龙芯目前正在全面优化虚拟化模拟的代码，以尽力将损耗压缩到 20% 以内。\n\n除了 LoongArch 以外，RISC-V 也是一个突破方向。\n\nRISC-V 是 2010 年新出现的开源精简指令集架构，架构设计上没有历史包袱，采用的理念和方法较为先进。和主流架构 x86/ARM 相比，RISC-V 架构篇幅更少，基本指令集更少，支持模块化和拓展性，而且为贯彻开源精神，目前 RISC-V 基金会已经有搬迁至瑞士的计划了，不过 RISC-V 架构出现时间晚，适配软件和工具方面沉淀不足，目前虽然由阿里达摩院推出了号称最强 RISC-V 的玄铁 910 芯片，不过总体上讲其生态环境构建尚需时间。\n\n\n\n国芯前路之晶圆制造：还需国家引导基础科学发展\n\n与 EDA 相同，晶圆制造也是一个需要时间积累的领域。在制造领域需要光刻机、光掩膜、光刻胶与芯片工艺相结合才行，这其中涉及太多基础物理、化学方面的知识。\n\n不过我国光刻技术的起步并不晚，早在上个世纪 60 年代，中科院就开始研究光刻机了，并且在 1965 年就研制出 65 型接触式光刻机，1972 年武汉无线电元件三厂编写的《光刻掩模的制造》的书中，具体讲述了当时那个时代，我们光刻技术的发展历程，后来 1980 年中国清华大学第四代分布式投影光刻机获得成功，将光刻精度缩小至 3 微米，这个制程与当时国际先进水平非常接近，有关这段往事笔者曾经在前文《国产芯回忆录：造光刻机的去卖早点，搞 EDA 的去组装电脑》中介绍过了，这里不加赘述了。\n\n而我们想在芯片制造方面突破，最关键的还是要靠国家层面的政策支持与引导。\n\n此外，我们也必须清醒的认识到，芯片虽然是 IT 领域的核心产业，但芯片制造却更偏向于基础科学的属性，只能结硬寨，打硬仗，没有捷径可言，这里笔者也呼吁业界同仁给予华为以及我国整个芯片业以更多耐心，以期破壁图强，逆境重生！', '英特尔火线换帅，苹果搅动乾坤，国芯路在何方？', '0', '2021-01-28 08:00:32');
INSERT INTO `article` VALUES ('4', '1', '0', '2', '2021-01-28 17:22:26', '芯片领域洗牌，国产芯片厂商的突破口在何处？\n\n作者 | 马超       责编 | 屠敏\n\n出品 | CSDN（ID：CSDNnews）\n\n“时来天地皆同力，运去英雄不自由”。\n\n计算机背后的集成电路已由上世纪 40 年代占地 150 平方米、重达 30 吨的庞然大物，演进成仅有手指般大小的超高密度的电子芯片。芯片是 IT 时代的算力底座，市场规模近万亿美元，但这个领域一直是我们被“卡脖子”的软肋。\n\n近日，接连不断的并购案和频繁涌现的新品发布，让芯片行业处于前所未有的大变局之中。\n\n去年 9 月，英伟达宣布以 400 亿美元的价格从软银手中收购 Arm，以加强自己在 CPU 方面的短板，凭借 CPU+GPU 的方式正式进军云数据中心；10 月，英特尔宣布将 NAND 业务以 90 亿美元的价格卖给 SK 海力士；同月，AMD 收购 FPGA 行业的巨头 Xilinx，同样剑指云数据中心；而这样纷繁复杂的局面在一代神芯苹果 M1 发布之后变得更加扑朔迷离。\n\n不仅如此，近期英特尔也官宣将在一个月后换帅，现任掌门人 Bob Swan 此前是英特尔的财务官，缺乏技术方面的专业背景。可能也正是由于这方面的欠缺，英特尔在技术层面衍生出许多问题，迟迟陷在 14nm 制程上无法突破，也带来了\"火线换帅\"的局面。\n\n此外，另一巨头英伟达带着 RTX3060 也正式登场，并采用了 3584 CUDA 核心，GPU 频率可达 1.78G Hz，配备了 12GB 的 GDDR6 显存，可以说英伟达在显卡市场上也开始拼尽全力了。\n\n\n\n在此趋势下，我们不仅要看清芯片巨头们的竞争格局，更要躬身入局，加快我们自身的追赶步伐。也希望本文能为正走在这条道路上的技术人们带来一些思考。\n\n\n\n苹果 M1 芯片“抗打”\n\n众所周知，IT 界每十年就会产生一种新的生态，如二十年前的 Wintel 的 PC 生态、如十年前 Android、iOS+ARM 形成的移动终端生态，未来的一两年内，想必也会有新生态形成，因此哪种芯片能够领先竞争对手，那么谁的生态就可能笑傲江湖，而统治 IT 生态对于科技巨头而言是保持基业常青的最大砝码，这也是苹果耗费巨大精力也要打造出 M1 的主要原因。\n\nM1 的优胜原因在于，目前计算机的体系架构更偏向于划定界限明确分工，CPU、内存等模块都是彼此都是独立的，不过 M1 打破了这个潜规则，本质上 M1 并不是一颗传统意义上的 CPU，而是 CPU、GPU、内存乃至协处理器集成在一块 SOC 上的微型主机。\n\n不过，这样做的缺点是扩展性差，使用 M1 的主机无法扩展内存，但这样的好处也非常明显，集成式 SOC 所带来的性能提升令人惊叹。据最新的评测来看，M1 的单核得分超过了 AMD 最新的 ZEN 3 架构的 Ryzen 9 5950X 和 Intel i9-10900K。\n\nM1 不仅 CPU 性能强悍，它的图形性能也很出众，已经完全脱离了之前业界对于集成显卡的理解范围。据数据显示，M1 的显卡性能与英伟达的 GTX 1650 与 GTX 1050Ti 之间，比目前轻薄本主流集成显卡性能高出好几个数量级。\n\n另外，M1 的功耗也非常低。据网友用《古墓丽影:崛起》进行测试案例结果时，M1 的平均功率分别是 CPU 7.5W、GPU 7W，作为对比仅是 1650 显卡功率要求就有 75W。\n\n这样的表现除了对笔记本桌面市场带来一定震撼外，也为云数据中心指明了一条道路。毕竟，云数据中心不仅对于电力消耗的要求极其高，而且如何为服务器降温更是一个巨大的课题，业界中如微软、Facebook 等企业此前为了解决这一难题甚至将数据中心建到海底，阿里云也有液冷服务器的技术，当然这些都是针对 CPU 这个耗能大户设计的，如果能 CPU 耗能低到 10w 以内，将对于云计算服务商产生巨大的吸引力。\n\n目前云操作系统基本是 Linux 的天下，这意味着，一旦低耗能高性能的 M1 可以平稳运行 Linux，那么云平台和 Android 平台的大量生态级应用就可以全部被 ARM 和开源的联盟收入囊中，这样带来的可能性正是开源社区正在全力向 M1 上移植 Linux 的原因，而如何面对 M1 集成式 SOC 的趋势将是今后各大巨头的必须要回答的问题。\n\n\n\n英特尔“求变”\n\n相比之下，另一科技巨头英特尔的处境似乎不太好，一直以来 CPU 领域的跟随者 AMD 已经大有后来者居上的气势，不但推出了 ZEN3 架构的 CPU，制程 7nm 性价比也全面超越它，并且还收购了人工智能领域 FPGA 芯片巨头赛灵思。\n\n英特尔在 14nm 制造上迟迟无法突破，而苹果这样的消费者硬件厂商，对于先进制程芯片带来的节能效应还是非常看重的，因此苹果发布自研 M1 终止与英特尔合作，这使得英特尔无论如何也不能再挤牙膏了。\n\n英特尔于日前宣布任命帕特.基辛格为新任 CEO，与前任 CEO 财务出身不同，基辛格是与英特尔一起成长起来的技术专家，新帅基辛格的回归势必要剑指先进制程。\n\n不过，近来以来，芯片市场中桌面业务明显趋于萎缩，而云计算领域却是不断增长，英伟达收购 ARM、AMD 收购赛灵思其实都是在布局云数据中心。在这里，不得不提一下基辛格的前东家，2012 年，基辛格接手 VMware CEO 一职，经过多年的努力，如今 VMware 在云计算方面几乎没有敌手，取得了营收翻 3 倍的成绩，且在虚拟化云计算领域也是佼佼者，因此基辛格的王者归来，让大家对英特尔充满了期待，也相信英特尔将很快会重新取得突破，迎来崭新未来。\n\n\n\nAMD vs NVIDIA：关键在制程\n\n在显卡市场，一直被英伟达（NVIDIA）吊打的 AMD 也在近期迎来了高光时刻，AMD 在去年年底发布的 RX6000 系列显卡在很多方面几乎反过来压制了英伟达同级别的 GPU。事实上，制约显卡性能最大的因素在于带宽，而RX6000 系列有 RDNA 2 无限缓存技术的加持，相比 RDNA 带宽提升 50%，频率提升 30%，这意味着 RDNA 2 的默频可以轻松达到 2G 以上，这对于性能的提升幅度将是巨大的，而微软官宣 XBox X|S 是全球唯一搭载 RDNA 2的游戏主机平台，这样的表态可以看作是微软对于 AMD 显卡性能的一种“背书”。\n\n而 AMD 能在 CPU 领域与英特尔一较长短，在 GPU 也能和英伟达正面较量的关键原因还是在于制程。\n\n此前，由于财务原因，AMD 在 2008 年底卖掉了自己的晶圆厂，自此以后，AMD 的主要芯片代工制造商就是台积电，这样的结盟使得 AMD 能够率先用上 7nm 的制程。正如我们上文所说，能掌握先进节能的芯片，对于 IT 厂商建立自身生态意义非凡，因此才会出现众巨头争抢台积电产能的情况。\n\n凭借对先进制程的把握与高超的芯片工艺水平，近些年来，英伟达也将很多之前属于三星的订单转投给台积电，根据今年三季度的财务，台积电这家芯片制造业的巨头今年的毛利润率已经达到了 53%，这代表他们芯片制造的成本还不到出厂价的一半，这在世界 500 强的公司当中是绝无仅有的，甚至远超被称为 IT 界奢侈品牌的苹果公司。\n\n建设和维护晶圆厂实在太花钱了，还需要不断按部就班的升级工艺，业界目前也就台积电和三星两大玩家。由于分工的明确化，台积电从起家就一直专注于芯片代工，不仅工艺升级非常快，而且在良品率上也很让人满意，而且台积电多年来从来没有涉及过芯片设计，对 AMD、英伟达这类客户芯片 IP 保护工作做的非常好，也正是由于专注在芯片制造，台积电才有精力和财力把业务做好做大，这也符合未来芯片行业的分工趋势。\n\n基于以上，在看清巨头的纷争后，我们还是要解决自己的问题，在打压了华为、大疆以后，最近美国又把目光盯上了小米、中微电子等公司，通过分析巨头们的策略，笔者认为针对芯片的不同领域，我们需要采用不同的策略加以应对。\n\n\n\n国芯前路之 EDA：\n\n相信时间累积而非资本力量\n\nEDA 其实是工业软件计算机辅助设计 CAD 的一个分支，依靠 EDA 工具，芯片设计人员可以从概念、算法、协议等开始设计电子系统，完成电子产品从电路设计、性能分析到设计出 IC 版图或 PCB 版图的整个过程。\n\n有数据显示，2018 年全球 EDA 市场规模还没突破 100 亿美元，EDA 相对于几千亿美元的芯片产业来说从产值上看根本不值一提，不过少了 EDA 整个芯片产业都得停摆。EDA 市场前三位的 Synopsys、Cadence 和西门子在我国 EDA 的市场份额达到 95% 以上，因此 EDA 软件是我们芯片行业亟待突破的第一关。\n\nEDA 行业是一个典型的小而美的行业，可分为前端和后端，前端主要负责逻辑实现，后端跟工艺紧密结合。\n\n与 MATLAB 等工业软件一样，EDA 的前端技术需要最新逻辑元件的资料输入，不过大部分国产 EDA 厂商还无法支持 7nm 的逻辑元件，与台积电、三星等顶级芯片制造商的联系较少，巧妇难为无米之炊，没有最新工艺资料 EDA 前端，很难真正做好。\n\nEDA 后端则需要高质量的模拟与仿真，这需要长时间的技术积累，乃至不断地并购才能保持自身在技术迭代的浪潮中保持优势的方法。笔者认为想解决国内的 EDA 软件问题，或可从以下几个方面入手：\n\n国家层面不断推动企业整合。这方面美国的经验非常值得我们借鉴，他们的 EDA 企业并非没有过恶性竞争，不过政府并没有放任这种竞争的持续而是直接出手干预了市场。EDA 三巨头之一的 Synopsys 成立以来，就发起几十余项并购交易，不断寻找那些在 EDA 功能模块中做得比较有特色的成功企业进行并购，从而使得自身能够覆盖前后端整个设计流程。\n\n尤其是 2002 年 Synopsys 在美国商务部、司法部的牵线下，以 8.3 亿美元收购了 Avanti 公司，使得 Synopsys 成为 EDA 历史上第一家可以提供顶级前后端完整 IC 设计方案的领先 EDA 工具供应商，并在 2008 年超越 Cadence 成为全球最大的 EDA 工具厂商。\n\n而值得注意的是，在此之前 Avanti 一直与 Cadence 公司深陷于专利官司之中，这场并购几乎由美国政府主导，也正是通过这样的并购，使得美国的 EDA 公司结束了专利内斗，迅速拓展并占领了海外市场。\n\n持续提高投入。以 EDA 的三巨头为例，从三家公司财务来看，其最大支出部分用于产品的研发，其中 Synopsys 和 Cadence 这两家公司在 2019 年的研发支出超过了 20 亿美元。\n\n加大人才培养力度。综合来看，国内包括芯愿景、华大九天等在内的 EDA 公司，最大短板在于研发力量的薄弱，而我们需要不断加强人才的培养与输出。\n\n\n\n国芯前路之指令集：重点突破优先\n\n既使有了 EDA 软件，进行芯片设计了，我们的芯片设计师们在动手之前，也必须先决定芯片的指令集。\n\n指令集之所以重要，举例说明，正如 x86 芯片中有 SSE（Stream SIMDExtentions）数据流单指令多数据扩展，SSE 系列指令提供了 8 个 128bit 的寄存器进行 SIMD 操作。\n\n目前主流的 CPU 是 64 位的，即在一个 CPU 振荡周期都只能处理 64 位长的数据并得到一个 64 位长的结果，而 SSE 的扩展恰恰就是可让 64 位的 CPU 在一个周期内对 128 位长的数据进行处理并得到 128 位长的结果，从而大幅提高双精度数据的处理效率。因此我们看到很多用于科学计算的软件包底层都是使用 C 语言内联嵌入 SSE 汇编指令的代码进行性能优化，并取得极好的效果。而 ARM 系列芯片的成名之作就是大小核，其中大核专门针对性能优化，小核专门针对功耗优化，可谓忙时用大核干得欢，闲时用小核歇得爽。像这样的芯片指令集都是被专利保护的，想使用必须得到 IP 授权，因此指令集也是一个我们必须直面困难的领域。\n\n目前我国拥有完整知识产权的芯片指令集就是龙芯在去年底时发布的 LoongArch。LoongArch 是一种可以支持模拟运行 x86 或者 ARM 的指令集，因此可以深度兼容 Windows、Linux、Android 程序，但是这种模拟运行也有性能损耗，而且从目前来看这种性能代价还是不小的，当然据笔者所知龙芯目前正在全面优化虚拟化模拟的代码，以尽力将损耗压缩到 20% 以内。\n\n除了 LoongArch 以外，RISC-V 也是一个突破方向。\n\nRISC-V 是 2010 年新出现的开源精简指令集架构，架构设计上没有历史包袱，采用的理念和方法较为先进。和主流架构 x86/ARM 相比，RISC-V 架构篇幅更少，基本指令集更少，支持模块化和拓展性，而且为贯彻开源精神，目前 RISC-V 基金会已经有搬迁至瑞士的计划了，不过 RISC-V 架构出现时间晚，适配软件和工具方面沉淀不足，目前虽然由阿里达摩院推出了号称最强 RISC-V 的玄铁 910 芯片，不过总体上讲其生态环境构建尚需时间。\n\n\n\n国芯前路之晶圆制造：还需国家引导基础科学发展\n\n与 EDA 相同，晶圆制造也是一个需要时间积累的领域。在制造领域需要光刻机、光掩膜、光刻胶与芯片工艺相结合才行，这其中涉及太多基础物理、化学方面的知识。\n\n不过我国光刻技术的起步并不晚，早在上个世纪 60 年代，中科院就开始研究光刻机了，并且在 1965 年就研制出 65 型接触式光刻机，1972 年武汉无线电元件三厂编写的《光刻掩模的制造》的书中，具体讲述了当时那个时代，我们光刻技术的发展历程，后来 1980 年中国清华大学第四代分布式投影光刻机获得成功，将光刻精度缩小至 3 微米，这个制程与当时国际先进水平非常接近，有关这段往事笔者曾经在前文《国产芯回忆录：造光刻机的去卖早点，搞 EDA 的去组装电脑》中介绍过了，这里不加赘述了。\n\n而我们想在芯片制造方面突破，最关键的还是要靠国家层面的政策支持与引导。\n\n此外，我们也必须清醒的认识到，芯片虽然是 IT 领域的核心产业，但芯片制造却更偏向于基础科学的属性，只能结硬寨，打硬仗，没有捷径可言，这里笔者也呼吁业界同仁给予华为以及我国整个芯片业以更多耐心，以期破壁图强，逆境重生！', '英特尔火线换帅，苹果搅动乾坤，22222222222222国芯路在何方？', '0', '2021-01-28 17:22:42');
INSERT INTO `article` VALUES ('21', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容0', '测试文章标题0', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('22', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1', '测试文章标题1', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('23', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容4', '测试文章标题4', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('24', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容9', '测试文章标题9', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('25', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容16', '测试文章标题16', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('26', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容25', '测试文章标题25', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('27', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容36', '测试文章标题36', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('28', '4', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容49', '测试文章标题49', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('29', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容64', '测试文章标题64', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('30', '4', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容81', '测试文章标题81', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('31', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容100', '测试文章标题100', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('32', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容121', '测试文章标题121', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('33', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容144', '测试文章标题144', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('34', '4', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容169', '测试文章标题169', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('35', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容196', '测试文章标题196', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('36', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容225', '测试文章标题225', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('37', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容256', '测试文章标题256', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('38', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容289', '测试文章标题289', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('39', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容324', '测试文章标题324', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('40', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容361', '测试文章标题361', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('41', '4', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容400', '测试文章标题400', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('42', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容441', '测试文章标题441', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('43', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容484', '测试文章标题484', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('44', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容529', '测试文章标题529', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('45', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容576', '测试文章标题576', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('46', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容625', '测试文章标题625', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('47', '4', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容676', '测试文章标题676', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('48', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容729', '测试文章标题729', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('49', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容784', '测试文章标题784', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('50', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容841', '测试文章标题841', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('51', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容900', '测试文章标题900', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('52', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容961', '测试文章标题961', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('53', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1024', '测试文章标题1024', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('54', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1089', '测试文章标题1089', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('55', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1156', '测试文章标题1156', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('56', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1225', '测试文章标题1225', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('57', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1296', '测试文章标题1296', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('58', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1369', '测试文章标题1369', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('59', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1444', '测试文章标题1444', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('60', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1521', '测试文章标题1521', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('61', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1600', '测试文章标题1600', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('62', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1681', '测试文章标题1681', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('63', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1764', '测试文章标题1764', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('64', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1849', '测试文章标题1849', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('65', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容1936', '测试文章标题1936', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('66', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容2025', '测试文章标题2025', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('67', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容2116', '测试文章标题2116', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('68', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容2209', '测试文章标题2209', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('69', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容2304', '测试文章标题2304', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('70', '4', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容2401', '测试文章标题2401', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('71', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容2500', '测试文章标题2500', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('72', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容2601', '测试文章标题2601', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('73', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容2704', '测试文章标题2704', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('74', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容2809', '测试文章标题2809', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('75', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容2916', '测试文章标题2916', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('76', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容3025', '测试文章标题3025', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('77', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容3136', '测试文章标题3136', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('78', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容3249', '测试文章标题3249', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('79', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容3364', '测试文章标题3364', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('80', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容3481', '测试文章标题3481', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('81', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容3600', '测试文章标题3600', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('82', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容3721', '测试文章标题3721', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('83', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容3844', '测试文章标题3844', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('84', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容3969', '测试文章标题3969', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('85', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容4096', '测试文章标题4096', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('86', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容4225', '测试文章标题4225', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('87', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容4356', '测试文章标题4356', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('88', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容4489', '测试文章标题4489', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('89', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容4624', '测试文章标题4624', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('90', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容4761', '测试文章标题4761', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('91', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容4900', '测试文章标题4900', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('92', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容5041', '测试文章标题5041', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('93', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容5184', '测试文章标题5184', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('94', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容5329', '测试文章标题5329', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('95', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容5476', '测试文章标题5476', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('96', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容5625', '测试文章标题5625', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('97', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容5776', '测试文章标题5776', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('98', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容5929', '测试文章标题5929', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('99', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容6084', '测试文章标题6084', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('100', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容6241', '测试文章标题6241', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('101', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容6400', '测试文章标题6400', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('102', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容6561', '测试文章标题6561', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('103', '1', '0', '2', '2021-01-28 09:33:25', '测试文章这是内容6724', '测试文章标题6724', '1', '2021-01-28 09:33:25');
INSERT INTO `article` VALUES ('104', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容6889', '测试文章标题6889', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('105', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容7056', '测试文章标题7056', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('106', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容7225', '测试文章标题7225', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('107', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容7396', '测试文章标题7396', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('108', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容7569', '测试文章标题7569', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('109', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容7744', '测试文章标题7744', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('110', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容7921', '测试文章标题7921', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('111', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容8100', '测试文章标题8100', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('112', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容8281', '测试文章标题8281', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('113', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容8464', '测试文章标题8464', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('114', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容8649', '测试文章标题8649', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('115', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容8836', '测试文章标题8836', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('116', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容9025', '测试文章标题9025', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('117', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容9216', '测试文章标题9216', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('118', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容9409', '测试文章标题9409', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('119', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容9604', '测试文章标题9604', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('120', '1', '0', '2', '2021-01-28 09:33:26', '测试文章这是内容9801', '测试文章标题9801', '1', '2021-01-28 09:33:26');
INSERT INTO `article` VALUES ('122', '4', '0', '2', '2021-01-28 12:21:56', '正文如下： 众所周知，事务和锁是mysql中非常重要功能，同时也是面试的重点和难点。本文会详细介绍事务和锁的相关概念及其实现原理，相信大家看完之后，一定会对事务和锁有更加深入的理解。整理了一份328页MySQL，PDF文档 什么是事务 在维基百科中，对事务的定义是：事务是数据库管理系统(DBMS)执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。 事务的四大特性 事务包含四大特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）(ACID)。 原子性（Atomicity） 原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的。 一致性（Consistency） 一致性是指数据库的完整性约束没有被破坏，在事务执行前后都是合法的数据状态。这里的一致可以表示数据库自身的约束没有被破坏，比如某些字段的唯一性约束、字段长度约束等等；还可以表示各种实际场景下的业务约束，比如上面转账操作，一个账户减少的金额和另一个账户增加的金额一定是一样的。 隔离性（Isolation） 隔离性指的是多个事务彼此之间是完全隔离、互不干扰的。隔离性的最终目的也是为了保证一致性。 持久性（Durability） 持久性是指只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态。 事务的状态 根据事务所处的不同阶段，事务大致可以分为以下5个状态： 活动的（active） 当事务对应的数据库操作正在执行过程中，则该事务处于活动状态。 部分提交的（partially committed） 当事务中的最后一个操作执行完成，但还未将变更刷新到磁盘时，则该事务处于部分提交状态。 失败的（failed） 当事务处于活动或者部分提交状态时，由于某些错误导致事务无法继续执行，则事务处于失败状态。 中止的（aborted） 当事务处于失败状态，且回滚操作执行完毕，数据恢复到事务执行之前的状态时，则该事务处于中止状态。 提交的（committed） 当事务处于部分提交状态，并且将修改过的数据都同步到磁盘之后，此时该事务处于提交状态。 事务隔离级别 前面提到过，事务必须具有隔离性。实现隔离性最简单的方式就是不允许事务并发，每个事务都排队执行，但是这种方式性能实在太差了。为了兼顾事务的隔离性和性能，事务支持不同的隔离级别。 为了方便表述后续的内容，我们先建一张示例表hero。 CREATE TABLE hero (  \n    number INT,  \n    name VARCHAR(100),  \n    country varchar(100),  \n    PRIMARY KEY (number)  \n) Engine=InnoDB CHARSET=utf8; 事务并发执行遇到的问题 在事务并发执行时，如果不进行任何控制，可能会出现以下4类问题： 脏写（Dirty Write） 脏写是指一个事务修改了其它事务未提交的数据。 如上图，Session A和Session B各开启了一个事务，Session B中的事务先将number列为1的记录的name列更新为\'关羽\'，然后Session A中的事务接着又把这条number列为1的记录的name列更新为张飞。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象就称之为脏写。 脏读（Dirty Read） 脏读是指一个事务读到了其它事务未提交的数据。 如上图，Session A和Session B各开启了一个事务，Session B中的事务先将number列为1的记录的name列更新为\'关羽\'，然后Session A中的事务再去查询这条number为1的记录，如果读到列name的值为\'关羽\'，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。 不可重复读（Non-Repeatable Read） 不可重复读指的是在一个事务执行过程中，读取到其它事务已提交的数据，导致两次读取的结果不一致。 如上图，我们在Session B中提交了几个隐式事务(mysql会自动为增删改语句加事务)，这些事务都修改了number列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为不可重复读。 幻读（Phantom） 幻读是指的是在一个事务执行过程中，读取到了其他事务新插入数据，导致两次读取的结果不一致。 如上图，Session A中的事务先根据条件number > 0这个条件查询表hero，得到了name列值为\'刘备\'的记录；之后Session B中提交了一个隐式事务，该事务向表hero中插入了一条新记录；之后Session A中的事务再根据相同的条件number > 0查询表hero，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为幻读。 不可重复读和幻读的区别在于不可重复读是读到的是其他事务修改或者删除的数据，而幻读读到的是其它事务新插入的数据。 脏写的问题太严重了，任何隔离级别都必须避免。其它无论是脏读，不可重复读，还是幻读，它们都属于数据库的读一致性的问题，都是在一个事务里面前后两次读取出现了不一致的情况。 四种隔离级别 在SQL标准中设立了4种隔离级别，用来解决上面的读一致性问题。不同的隔离级别可以解决不同的读一致性问题。 READ UNCOMMITTED：未提交读。 READ COMMITTED：已提交读。 REPEATABLE READ：可重复读。 SERIALIZABLE：串行化。 各个隔离级别下可能出现的读一致性问题如下： InnoDB支持四个隔离级别（和SQL标准定义的基本一致）。隔离级别越高，事务的并发度就越低。唯一的区别就在于，InnoDB 在可重复读（REPEATABLE READ）的级别就解决了幻读的问题。这也是InnoDB使用可重复读 作为事务默认隔离级别的原因。 MVCC MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。 版本链 在InnoDB中，每行记录实际上都包含了两个隐藏字段：事务id(trx_id)和回滚指针(roll_pointer)。 trx_id：事务id。每次修改某行记录时，都会把该事务的事务id赋值给trx_id隐藏列。 roll_pointer：回滚指针。每次修改某行记录时，都会把undo日志地址赋值给roll_pointer隐藏列。 假设hero表中只有一行记录，当时插入的事务id为80。此时，该条记录的示例图如下： 假设之后两个事务id分别为100、200的事务对这条记录进行UPDATE操作，操作流程如下： 由于每次变动都会先把undo日志记录下来，并用roll_pointer指向undo日志地址。因此可以认为，对该条记录的修改日志串联起来就形成了一个版本链，版本链的头节点就是当前记录最新的值。如下： ReadView 如果数据库隔离级别是未提交读（READ UNCOMMITTED），那么读取版本链中最新版本的记录即可。如果是是串行化（SERIALIZABLE），事务之间是加锁执行的，不存在读不一致的问题。但是如果是已提交读（READ COMMITTED）或者可重复读（REPEATABLE READ），就需要遍历版本链中的每一条记录，判断该条记录是否对当前事务可见，直到找到为止(遍历完还没找到就说明记录不存在)。InnoDB通过ReadView实现了这个功能。ReadView中主要包含以下4个内容： m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。 min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。 max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。 creator_trx_id：表示生成该ReadView事务的事务id。 有了ReadView之后，我们可以基于以下步骤判断某个版本的记录是否对当前事务可见。 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。 在MySQL中，READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。READ COMMITTED在每次读取数据前都会生成一个ReadView，这样就能保证每次都能读到其它事务已提交的数据。REPEATABLE READ 只在第一次读取数据时生成一个ReadView，这样就能保证后续读取的结果完全一致。 锁 事务并发访问同一数据资源的情况主要就分为读-读、写-写和读-写三种。 读-读 即并发事务同时访问同一行数据记录。由于两个事务都进行只读操作，不会对记录造成任何影响，因此并发读完全允许。 写-写 即并发事务同时修改同一行数据记录。这种情况下可能导致脏写问题，这是任何情况下都不允许发生的，因此只能通过加锁实现，也就是当一个事务需要对某行记录进行修改时，首先会先给这条记录加锁，如果加锁成功则继续执行，否则就排队等待，事务执行完成或回滚会自动释放锁。 读-写 即一个事务进行读取操作，另一个进行写入操作。这种情况下可能会产生脏读、不可重复读、幻读。最好的方案是读操作利用多版本并发控制（MVCC），写操作进行加锁。 锁的粒度 按锁作用的数据范围进行分类的话，锁可以分为行级锁和表级锁。 行级锁：作用在数据行上，锁的粒度比较小。 表级锁：作用在整张数据表上，锁的粒度比较大。 锁的分类 为了实现读-读之间不受影响，并且写-写、读-写之间能够相互阻塞，Mysql使用了读写锁的思路进行实现，具体来说就是分为了共享锁和排它锁： 1.共享锁(Shared Locks)：简称S锁，在事务要读取一条记录时，需要先获取该记录的S锁。S锁可以在同一时刻被多个事务同时持有。我们可以用select ...... lock in share mode;的方式手工加上一把S锁。 2.排他锁(Exclusive Locks)：简称X锁，在事务要改动一条记录时，需要先获取该记录的X锁。X锁在同一时刻最多只能被一个事务持有。X锁的加锁方式有两种，第一种是自动加锁，在对数据进行增删改的时候，都会默认加上一个X锁。还有一种是手工加锁，我们用一个FOR UPDATE给一行数据加上一个X锁。 还需要注意的一点是，如果一个事务已经持有了某行记录的S锁，另一个事务是无法为这行记录加上X锁的，反之亦然。 除了共享锁(Shared Locks)和排他锁(Exclusive Locks)，Mysql还有意向锁(Intention Locks)。意向锁是由数据库自己维护的，一般来说，当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加一个意向共享锁(IS锁)；当我们给一行数据加上排他锁之前，数据库会自动在这张表上面加一个意向排他锁(IX锁)。意向锁可以认为是S锁和X锁在数据表上的标识，通过意向锁可以快速判断表中是否有记录被上锁，从而避免通过遍历的方式来查看表中有没有记录被上锁，提升加锁效率。例如，我们要加表级别的X锁，这时候数据表里面如果存在行级别的X锁或者S锁的，加锁就会失败，此时直接根据意向锁就能知道这张表是否有行级别的X锁或者S锁。 InnoDB中的表级锁 InnoDB中的表级锁主要包括表级别的意向共享锁(IS锁)和意向排他锁(IX锁)以及自增锁(AUTO-INC锁)。其中IS锁和IX锁在前面已经介绍过了，这里不再赘述，我们接下来重点了解一下AUTO-INC锁。 大家都知道，如果我们给某列字段加了AUTO_INCREMENT自增属性，插入的时候不需要为该字段指定值，系统会自动保证递增。系统实现这种自动给AUTO_INCREMENT修饰的列递增赋值的原理主要是两个： 1.AUTO-INC锁：在执行插入语句的时先加上表级别的AUTO-INC锁，插入执行完成后立即释放锁。如果我们的插入语句在执行前无法确定具体要插入多少条记录，比如INSERT ... SELECT这种插入语句，一般采用AUTO-INC锁的方式。 2.轻量级锁：在插入语句生成AUTO_INCREMENT值时先才获取这个轻量级锁，然后在AUTO_INCREMENT值生成之后就释放轻量级锁。如果我们的插入语句在执行前就可以确定具体要插入多少条记录，那么一般采用轻量级锁的方式对AUTO_INCREMENT修饰的列进行赋值。这种方式可以避免锁定表，可以提升插入性能。 “mysql默认根据实际场景自动选择加锁方式，当然也可以通过innodb_autoinc_lock_mode强制指定只使用其中一种。” InnoDB中的行级锁 前面说过，通过MVCC可以解决脏读、不可重复读、幻读这些读一致性问题，但实际上这只是解决了普通select语句的数据读取问题。事务利用MVCC进行的读取操作称之为快照读，所有普通的SELECT语句在READ COMMITTED、REPEATABLE READ隔离级别下都算是快照读。除了快照读之外，还有一种是锁定读，即在读取的时候给记录加锁，在锁定读的情况下依然要解决脏读、不可重复读、幻读的问题。由于都是在记录上加锁，这些锁都属于行级锁。 InnoDB的行锁，是通过锁住索引来实现的，如果加锁查询的时候没有使用过索引，会将整个聚簇索引都锁住，相当于锁表了。根据锁定范围的不同，行锁可以使用记录锁(Record Locks)、间隙锁(Gap Locks)和临键锁(Next-Key Locks)的方式实现。假设现在有一张表t，主键是id。我们插入了4行数据，主键值分别是 1、4、7、10。接下来我们就以聚簇索引为例，具体介绍三种形式的行锁。 记录锁(Record Locks) 所谓记录，就是指聚簇索引中真实存放的数据，比如上面的1、4、7、10都是记录。 显然，记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如select * from t where id =4 for update;就会将id=4的记录锁定。 间隙锁(Gap Locks) 间隙指的是两个记录之间逻辑上尚未填入数据的部分，比如上述的(1,4)、(4,7)等。 同理，间隙锁就是锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个record，此时就会将对应的间隙区间锁定。例如select from t where id =3 for update;或者select from t where id > 1 and id < 4 for update;就会将(1,4)区间锁定。 临键锁(Next-Key Locks) 临键指的是间隙加上它右边的记录组成的左开右闭区间。比如上述的(1,4]、(4,7]等。 临键锁就是记录锁(Record Locks)和间隙锁(Gap Locks)的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分record记录，此时锁住的就是临键区间。注意，临键锁锁住的区间会包含最后一个record的右边的临键区间。例如select * from t where id > 5 and id <= 7 for update;会锁住(4,7]、(7,+∞)。mysql默认行锁类型就是临键锁(Next-Key Locks)。当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。 间隙锁(Gap Locks)和临键锁(Next-Key Locks)都是用来解决幻读问题的，在已提交读（READ COMMITTED）隔离级别下，间隙锁(Gap Locks)和临键锁(Next-Key Locks)都会失效！整理了一份328页MySQL，PDF文档', '陌陌面试官：谈谈你对MySQL中事务和锁的理解？', '1', '2021-01-28 12:21:56');

-- ----------------------------
-- Table structure for discuss
-- ----------------------------
DROP TABLE IF EXISTS `discuss`;
CREATE TABLE `discuss` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `uId` int(11) DEFAULT NULL COMMENT '外键  用户主键',
  `aId` int(11) DEFAULT NULL COMMENT '文章主键',
  `glike` int(11) DEFAULT NULL COMMENT '点赞次数',
  `comment_time` date DEFAULT NULL COMMENT '评论时间',
  `Rinfo` text COMMENT '评论信息',
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of discuss
-- ----------------------------

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(25) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `username` varchar(25) DEFAULT NULL COMMENT '用户名',
  `password` varchar(50) DEFAULT NULL COMMENT '密码',
  `phone` varchar(25) DEFAULT NULL COMMENT '手机',
  `city` varchar(50) DEFAULT NULL COMMENT '地址',
  `sex` bigint(20) DEFAULT NULL COMMENT ' 性别：1 - 男   2 - 女',
  `birthday` date DEFAULT NULL COMMENT '生日',
  `face` varchar(255) DEFAULT NULL COMMENT '头像',
  `state` bigint(20) DEFAULT NULL COMMENT '状态 0-未激活 1-正常 2-停用',
  `nickname` varchar(25) DEFAULT NULL COMMENT '昵称',
  `signature` varchar(255) DEFAULT '' COMMENT '描述',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', 'bb', '4297f44b13955235245b2497399d7a93', '13110787392', '厦门', '1', '2021-01-26', 'aaaa', '1', 'H', 'wo', '2021-01-26 15:06:13', '2021-01-26 15:06:13');
INSERT INTO `user` VALUES ('2', 'Herther', '4297f44b13955235245b2497399d7a93', '13110787392', '福州', '2', '2021-01-25', 'http://localhost:8080/upload/159daa00096042908f712dfdc2050baf.jpg', '1', 'Hether', 'hehehe', '2021-01-26 07:15:12', '2021-01-26 07:15:12');
INSERT INTO `user` VALUES ('3', 'Hether', '4297f44b13955235245b2497399d7a93', '13110373951', '龙岩', '1', '2021-01-25', 'aaaa', '1', 'Herther', '123', '2021-01-26 07:21:45', '2021-01-26 07:21:45');
INSERT INTO `user` VALUES ('9', 'Herther1', '4297f44b13955235245b2497399d7a93', '13110898392', '厦门', '1', '2021-01-26', null, '1', 'Herther1', '123123', '2021-01-27 05:47:34', '2021-01-27 05:47:34');
